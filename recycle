 //
                        //  read displacements
                        //  - deprecated, as stress can be computed in matlab
                        //
                        // var displacementFileLabels = ['before', 'after'];
                        // FORTE.design.displacements = [];
                        // for (var i = 0; i < displacementFileLabels.length; i++) {
                        //     // for (label of displacementFileLabels) {
                        //     var label = displacementFileLabels[i];
                        //     XAC.readTextFile(baseDir + '_' + label + '.dsp', function (text) {
                        //         var displacements = text.split('\n');
                        //         for (var i = 0; i < displacements.length; i++) {
                        //             var disp = parseFloat(displacements[i]);
                        //             if (!isNaN(disp)) displacements[i] = disp;
                        //         }
                        //         FORTE.design.displacements.push(displacements);
                        //         var layer = label == 'before' ? FORTE.designLayer : FORTE.optimizedLayer;
                        //         var height = FORTE.resolution[1];
                        //         var width = FORTE.resolution[0];

                        //         // need to fix the global value
                        //         var maxStress = layer.updateStress(displacements, FORTE.design.bbox.xmin, FORTE.design.bbox.ymin,
                        //             width, height, layer._bitmap, 0.1);
                        //         if (label == 'after') FORTE.updateStressAcrossLayers(maxStress);
                        //     });
                        // }

//
//
//
// FORTE.GridCanvas.prototype._computeAlphaMap = function (kernelSize) {
//     var sigma = 0.5;
//     var gaussian = generateGaussianKernel(2 * kernelSize + 1, sigma);
//     var rawAlphaMap = XAC.initMDArray([this._gridHeight, this._gridWidth], 0);
//     for (var j = 0; j < this._gridHeight; j++) {
//         for (var i = 0; i < this._gridWidth; i++) {
//             rawAlphaMap[j][i] = Math.pow(this._bitmap[j][i], FORTE.P);
//         }
//     }

//     var alphaMap = XAC.initMDArray([this._gridHeight, this._gridWidth], 0);
//     for (var j = 0; j < this._gridHeight; j++) {
//         for (var i = 0; i < this._gridWidth; i++) {
//             // var ncount = 0;
//             for (var rj = -kernelSize; rj <= kernelSize; rj++) {
//                 for (var ri = -kernelSize; ri <= kernelSize; ri++) {
//                     var jj = Math.min(Math.max(j + rj, 0), this._gridHeight - 1);
//                     var ii = Math.min(Math.max(i + ri, 0), this._gridWidth - 1);
//                     var idxGaussian = (rj + kernelSize) * (2 * kernelSize + 1) + ri + kernelSize;
//                     alphaMap[j][i] += gaussian[idxGaussian] * rawAlphaMap[jj][ii];
//                     // ncount++;
//                 }
//             }
//             // if (ncount > 0) alphaMap[j][i] /= ncount;
//         }
//     }
//     return alphaMap;
// }


// //
// //
// //
// FORTE.customizeEraserLayer = function () {
//     FORTE.eraserLayer._defaultAlpha = 1;

//     FORTE.eraserLayer._canvas.css('opacity', this._defaultAlpha);

//     FORTE.eraserLayer._canvas.mousedown(function (e) {
//         for (layer of FORTE.layers) {
//             if (layer != this) {
//                 layer.enable();
//                 // layer._context.fillStyle = this._context.fillStyle;
//                 layer.drawDown(e, true);
//             }
//         }
//     }.bind(FORTE.eraserLayer));

//     FORTE.eraserLayer._canvas.mousemove(function (e) {
//         for (layer of FORTE.layers)
//             if (layer != this) layer.drawMove(e, true);
//     }.bind(FORTE.eraserLayer));

//     FORTE.eraserLayer._canvas.mouseup(function (e) {
//         if (!this._enabled) return;
//         this._isDown = false;

//         if (FORTE.focusedDesignLayer != undefined) {
//             this._context.clearRect(0, 0, this._canvas[0].width, this._canvas[0].height);
//             FORTE.design.lastOutputFile = FORTE.focusedDesignLayer.lastOutputFile;
//             FORTE.startOptimization(FORTE.GETVARIATION)
//         } else {
//             var toRemoveLoadPoints = [];
//             var toRemoveLoadValues = [];
//             for (var i = 0; i < FORTE.design.loadPoints.length; i++) {
//                 var points = FORTE.design.loadPoints[i];
//                 for (p of points) {
//                     var done = false;
//                     for (q of this._strokePoints) {
//                         if (p[0] == q.x && p[1] == q.y) {
//                             toRemoveLoadPoints.push(points);
//                             toRemoveLoadValues.push(FORTE.design.loadValues[i]);
//                             FORTE.loadLayer.eraseArrow(i);

//                             for (e of FORTE.loadLayer._loadInputs[i]) FORTE.loadLayer._doDraw(e, true);

//                             done = true;
//                             break;
//                         }
//                     } // each stroke point
//                     if (done) break;
//                 } // each load point
//             } // each load point array

//             for (points of toRemoveLoadPoints) FORTE.design.loadPoints.remove(points);
//             for (values of toRemoveLoadValues) FORTE.design.loadValues.remove(values);

//             for (layer of FORTE.layers) {
//                 if (layer != this) {
//                     // layer.eraseInLayer(this._strokePoints);
//                     layer.drawUp(e);
//                     layer._context.fillStyle = layer._strokeColor;
//                 }
//             }
//         }
//     }.bind(FORTE.eraserLayer));
// }

// XAC.on(XAC.UPARROW, function (e) {
    //     FORTE.m *= 2;
    //     log(FORTE.m);
    // });
    // XAC.on(XAC.DOWNARROW, function (e) {
    //     FORTE.m /= 2;
    //     log(FORTE.m);
    // });
    // FORTE.maskLayers = [];
    // FORTE.lessMaterialLayer = new FORTE.MaskCanvas($('#tdCanvas'), FORTE.width, FORTE.height);
    // FORTE.layers.push(FORTE.lessMaterialLayer);

    // FORTE.lessMaterialLayer.disable(0);
    // XAC.on('L', function (e) {
    //     FORTE.lessMaterialLayer = new FORTE.MaskCanvas($('#tdCanvas'), FORTE.width, FORTE.height);
    //     FORTE.layers.push(FORTE.lessMaterialLayer);
    //     FORTE.switchLayer(FORTE.layers.indexOf(FORTE.lessMaterialLayer));
    //     FORTE.lessMaterialLayer.enable();
    // });
    
    // XAC.on('S', function (e) {
    //     FORTE.toShowStress = !FORTE.toShowStress;
    //     FORTE.updateStressAcrossLayers(FORTE.toShowStress);
    // });



//
// [obselete]
//
// FORTE.smoothLine = function (points, r) {
//     var eps = 10e-4;
//     var lambda = 0.382;
//     var nitr = 0;
//     while (true) {
//         nitr++;

//         var pointsNew = [points[0]];
//         var noUpdate = true;
//         for (var i = 1; i < points.length - 1; i++) {
//             var v0 = points[i - 1];
//             var v1 = points[i];
//             var v2 = points[i + 1];

//             // find the center from v0, v2, assuming the bend radius
//             var t = v1.clone().sub(v0).cross(v2.clone().sub(v1));
//             var u = v2.clone().sub(v0);
//             var w = t.cross(u).normalize();
//             var height = Math.sqrt(Math.pow(r, 2) - Math.pow(u.length() / 2, 2));
//             var c = v0.clone().add(u.divideScalar(2)).add(w.clone().multiplyScalar(height));

//             // if v1 is in this bend-radius-circle, it means a v0-v1-v2 circle has a >r radius
//             if (v1.distanceTo(c) <= r + eps) {
//                 pointsNew.push(v1);
//                 continue;
//             }

//             noUpdate = false;

//             // where v1 should be to fit the bend radius
//             var v1target = c.clone().sub(w.clone().multiplyScalar(r));

//             // interpret v1 to the target position
//             var lambda1 = lambda * r / v1.distanceTo(c);
//             var v1intrpr = v1.clone().multiplyScalar(lambda1).add(v1target.multiplyScalar(1 - lambda1));
//             pointsNew.push(v1intrpr);
//         }
//         pointsNew.push(points.last());

//         if (noUpdate) break;

//         for (var i = 1; i < points.length - 1; i++) {
//             points[i].copy(pointsNew[i]);
//         }
//     }
// }

// ......................................................................................................
//
//  >>>>>>>>>>>>>>>> 08/2017: currently unused <<<<<<<<<<<<<<<<<
//
//  routines for analyzing stress
//
//  by xiangchen@acm.org, v0.1, 07/2017
//
// ......................................................................................................

//
//  update the stress information, stored in a canvas
//
//      - displacements
//      - x0, y0: the origin of the design relative to the canvas
//      - width, height: the width and height of the design as a sub area of the canvas
//      - bitmap: the bitmap showing material density of the elements
//      - thres: the threshold value to decide when to discard an element
//
FORTE.GridCanvas.prototype.updateStress = function (displacements, x0, y0, width, height, bitmap, thres) {
    this._stressInfo = FORTE.computeStress(displacements, x0, y0, width, height, bitmap, thres);
    this._stressInfo.x0 = x0;
    this._stressInfo.y0 = y0;
    this._stressInfo.width = width;
    this._stressInfo.height = height;
    return this._stressInfo.maxStress;
}

//
//  update a canvas' heatmap based on udpated maximum stress across a set of designs
//
FORTE.GridCanvas.prototype.updateHeatmap = function (maxStress, map) {
    if (this._stressInfo == undefined) return;

    var defaultColor = XAC.getHeatmapColor(0, maxStress);
    this._heatmap = XAC.initMDArray([this._gridHeight, this._gridWidth], defaultColor);
    for (var j = 0; j < this._stressInfo.height; j++) {
        for (var i = 0; i < this._stressInfo.width; i++) {
            if(this._stressInfo.stresses[j] == undefined)return;
            var stress = FORTE.mapToUnits(this._stressInfo.stresses[j][i]);
            this._heatmap[j + this._stressInfo.y0][i + this._stressInfo.x0] =
                XAC.getHeatmapColor(stress, maxStress);
        }
    }
    return this._heatmap;
}

//
//  compute stress
//
//      for parameters see FORTE.GridCanvas.prototype.updateStress
//
FORTE.computeStress = function (displacements, x0, y0, width, height, bitmap, thres) {
    var E0 = 1,
        Emin = 1e-9;
    // var E = 1,
    //     nu = 0.3;
    // var C = [
    //     [1.125 * E, 0.375 * E, 0],
    //     [0.375 * E, 1.125 * E, 0],
    //     [0, 0, 0.375 * E]
    // ];
    var B = [
        [-0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0],
        [0, -0.5, 0, -0.5, 0, 0.5, 0, 0.5],
        [-0.5, -0.5, -0.5, 0.5, 0.5, 0.5, 0.5, -0.5]
    ];
    // var cb = numeric.dot(C, B);
    var sq = function (x) {
        return x * x;
    };

    var vonMises = [];
    var maxStress = 0;
    // var allStresses = [];
    for (var j = 0; j < height; j++) {
        var vmrow = [];
        for (var i = 0; i < width; i++) {
            //  3---2
            //  |   |
            //  0---1

            var n0 = i * (height + 1) + j + 1;
            var n1 = (i + 1) * (height + 1) + j + 1;
            var n2 = (i + 1) * (height + 1) + j;
            var n3 = i * (height + 1) + j;
            var nodes = [n0, n1, n2, n3];

            var arrDisps = [];

            // for (node of nodes) arrDisps.push(displacements[node]);
            for (node of nodes) arrDisps.push(displacements[2 * node], displacements[2 * node + 1]);

            var density = Math.pow(bitmap[y0 + j][x0 + i], 3); // < thres ? 0 : 1;
            var E = Emin + density * (E0 - Emin);

            var C = [
                [1.0989 * E, 0.3297 * E, 0],
                [0.3297 * E, 1.100 * E, 0],
                [0, 0, 0.3846 * E]
            ];
            var cb = numeric.dot(C, B);

            var sigma = numeric.dot(cb, numeric.transpose([arrDisps]));
            var s11 = sigma[0][0];
            var s22 = sigma[1][0];
            // var s33 = 0;
            var s12 = sigma[2][0];
            // var s23 = 0 * 0.5;
            // var s31 = 0 * 0.5;

            // 3d von mises
            // var stress = Math.sqrt(0.5 * (sq(s11 - s22) + sq(s22 - s33) + sq(s33 - s11) +
            //     6 * (sq(s12) + sq(s23) + sq(s31))));

            var stress = Math.sqrt(s11 * s11 + s22 * s22 + s12 * s12 - s11 * s22 + 2 * s12 * s12);

            //
            //  [debug] computing displacement per element
            //

            // var vdisp = {
            //     x: 0,
            //     y: 0
            // };

            // for (node of nodes) {
            //     vdisp.x += displacements[2 * node];
            //     vdisp.y += displacements[2 * node + 1];
            // }

            // vdisp.x /= 4;
            // vdisp.y /= 4;

            // var disp = Math.sqrt(Math.pow(vdisp.x, 2) + Math.pow(vdisp.y, 2));


            if (!isNaN(stress)) {
                vmrow.push(stress);
                maxStress = Math.max(maxStress, stress);
                // allStresses.push(stress);
            } else {
                vmrow.push(0);
                // allStresses.push(0);
            }
        }
        vonMises.push(vmrow);
    }

    // [debug]
    // var __trim = function (value, ndigits) {
    //     if (ndigits < 1) return value;
    //     var divider = Math.pow(10, ndigits);
    //     return ((value * divider) | 0) / (divider * 1.0);
    // }
    // for (var i = 0; i < width; i++) {
    //     vmcol = [];
    //     for (var j = 0; j < height; j++) vmcol.push(__trim(vonMises[j][i], 4));
    //     log(vmcol);
    // }

    // allStresses.sort(function (x, y) {
    //     if (x < y) return -1
    //     else if (x > y) return 1;
    //     else return 0
    // });

    // log(allStresses)

    log(maxStress)

    return {
        stresses: vonMises,
        maxStress: maxStress
    };
}